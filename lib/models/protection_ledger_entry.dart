// lib/models/protection_ledger_entry.dart
//
// Model for protection ledger entries (tax and safety allocations).
// Used by ProtectionLedgerRepository for CRUD operations.

/// Type of protection allocation
enum ProtectionAllocationType {
  tax,
  safety;

  String get dbValue {
    switch (this) {
      case ProtectionAllocationType.tax:
        return 'tax';
      case ProtectionAllocationType.safety:
        return 'safety';
    }
  }

  static ProtectionAllocationType fromDbValue(String value) {
    switch (value.toLowerCase()) {
      case 'tax':
        return ProtectionAllocationType.tax;
      case 'safety':
        return ProtectionAllocationType.safety;
      default:
        throw ArgumentError('Unknown allocation type: $value');
    }
  }
}

/// Direction of the ledger entry
enum ProtectionDirection {
  credit,
  debit;

  String get dbValue {
    switch (this) {
      case ProtectionDirection.credit:
        return 'credit';
      case ProtectionDirection.debit:
        return 'debit';
    }
  }

  static ProtectionDirection fromDbValue(String value) {
    switch (value.toLowerCase()) {
      case 'credit':
        return ProtectionDirection.credit;
      case 'debit':
        return ProtectionDirection.debit;
      default:
        throw ArgumentError('Unknown direction: $value');
    }
  }
}

/// A single entry in the protection ledger.
/// Credits come from income allocations, debits from safety drawdowns.
class ProtectionLedgerEntry {
  final String id;
  final String userId;
  final int? sourceTransactionId; // BIGINT in DB
  final int? triggerTransactionId; // BIGINT in DB
  final ProtectionAllocationType allocationType;
  final ProtectionDirection direction;
  final double? percentageAtTime; // 0.0-1.0 decimal
  final double amount;
  final DateTime effectiveAt;
  final String monthKey; // Generated by DB
  final DateTime createdAt;

  const ProtectionLedgerEntry({
    required this.id,
    required this.userId,
    this.sourceTransactionId,
    this.triggerTransactionId,
    required this.allocationType,
    required this.direction,
    this.percentageAtTime,
    required this.amount,
    required this.effectiveAt,
    required this.monthKey,
    required this.createdAt,
  });

  /// Parse from Supabase row map with robust type handling.
  /// Throws ArgumentError if required fields are missing.
  factory ProtectionLedgerEntry.fromMap(Map<String, dynamic> map) {
    // Parse id (required)
    final rawId = map['id'];
    if (rawId == null) {
      throw ArgumentError('Missing required field: id');
    }
    final id = rawId.toString();

    // Parse user_id (required)
    final rawUserId = map['user_id'];
    if (rawUserId == null) {
      throw ArgumentError('Missing required field: user_id');
    }
    final userId = rawUserId.toString();

    // Parse allocation_type (required)
    final rawAllocationType = map['allocation_type'];
    if (rawAllocationType == null) {
      throw ArgumentError('Missing required field: allocation_type');
    }
    final allocationType = ProtectionAllocationType.fromDbValue(
      rawAllocationType.toString(),
    );

    // Parse direction (required)
    final rawDirection = map['direction'];
    if (rawDirection == null) {
      throw ArgumentError('Missing required field: direction');
    }
    final direction = ProtectionDirection.fromDbValue(rawDirection.toString());

    // Parse amount (required, numeric)
    final rawAmount = map['amount'];
    if (rawAmount == null) {
      throw ArgumentError('Missing required field: amount');
    }
    final amount = _parseDouble(rawAmount);

    // Parse percentage_at_time (optional, 0.0-1.0)
    final rawPercentage = map['percentage_at_time'];
    final percentageAtTime =
        rawPercentage != null ? _parseDouble(rawPercentage) : null;

    // Parse source_transaction_id (optional, BIGINT -> int)
    final rawSourceTxId = map['source_transaction_id'];
    final sourceTransactionId =
        rawSourceTxId != null ? _parseInt(rawSourceTxId) : null;

    // Parse trigger_transaction_id (optional, BIGINT -> int)
    final rawTriggerTxId = map['trigger_transaction_id'];
    final triggerTransactionId =
        rawTriggerTxId != null ? _parseInt(rawTriggerTxId) : null;

    // Parse effective_at (required)
    final rawEffectiveAt = map['effective_at'];
    if (rawEffectiveAt == null) {
      throw ArgumentError('Missing required field: effective_at');
    }
    final effectiveAt = _parseDateTime(rawEffectiveAt);

    // Parse month_key (required, generated by DB)
    final rawMonthKey = map['month_key'];
    if (rawMonthKey == null) {
      throw ArgumentError('Missing required field: month_key');
    }
    final monthKey = rawMonthKey.toString();

    // Parse created_at (required)
    final rawCreatedAt = map['created_at'];
    if (rawCreatedAt == null) {
      throw ArgumentError('Missing required field: created_at');
    }
    final createdAt = _parseDateTime(rawCreatedAt);

    return ProtectionLedgerEntry(
      id: id,
      userId: userId,
      sourceTransactionId: sourceTransactionId,
      triggerTransactionId: triggerTransactionId,
      allocationType: allocationType,
      direction: direction,
      percentageAtTime: percentageAtTime,
      amount: amount,
      effectiveAt: effectiveAt,
      monthKey: monthKey,
      createdAt: createdAt,
    );
  }

  /// Prepare map for Supabase insert.
  /// Does NOT include month_key (generated by DB).
  /// Uses this.userId from the model.
  Map<String, dynamic> toInsertMap() {
    final map = <String, dynamic>{
      'user_id': userId,
      'allocation_type': allocationType.dbValue,
      'direction': direction.dbValue,
      'amount': amount,
    };

    if (sourceTransactionId != null) {
      map['source_transaction_id'] = sourceTransactionId;
    }
    if (triggerTransactionId != null) {
      map['trigger_transaction_id'] = triggerTransactionId;
    }
    if (percentageAtTime != null) {
      map['percentage_at_time'] = percentageAtTime;
    }
    // Note: effective_at is NOT included here.
    // For credits, the DB trigger sets it from source transaction date.
    // For debits, DB default (now()) applies.

    return map;
  }

  /// Parse numeric value to double (handles int, num, String).
  static double _parseDouble(dynamic value) {
    if (value is int) return value.toDouble();
    if (value is double) return value;
    if (value is num) return value.toDouble();
    if (value is String) {
      final parsed = double.tryParse(value);
      if (parsed != null) return parsed;
    }
    throw ArgumentError('Cannot parse to double: $value');
  }

  /// Parse numeric value to int (handles int, num, String).
  static int _parseInt(dynamic value) {
    if (value is int) return value;
    if (value is num) return value.toInt();
    if (value is String) {
      final parsed = int.tryParse(value);
      if (parsed != null) return parsed;
    }
    throw ArgumentError('Cannot parse to int: $value');
  }

  /// Parse DateTime (handles String, DateTime).
  static DateTime _parseDateTime(dynamic value) {
    if (value is DateTime) return value;
    if (value is String) {
      final parsed = DateTime.tryParse(value);
      if (parsed != null) return parsed;
    }
    throw ArgumentError('Cannot parse to DateTime: $value');
  }

  @override
  String toString() {
    return 'ProtectionLedgerEntry('
        'id: $id, '
        'allocationType: ${allocationType.dbValue}, '
        'direction: ${direction.dbValue}, '
        'amount: $amount, '
        'monthKey: $monthKey'
        ')';
  }
}
